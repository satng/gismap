define(["./defaultValue-81eec7ed","./Matrix2-c430e55a","./Transforms-4ee811db","./ComponentDatatype-9e86ac8f","./RuntimeError-8952249c","./GeometryAttribute-51ed9bde","./GeometryAttributes-32b29525","./IndexDatatype-bed3935d","./VertexFormat-7df34ea5","./WallGeometryLibrary-7330e8e1","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./arrayRemoveDuplicates-1a15bd09","./PolylinePipeline-b3067570","./EllipsoidGeodesic-22d2f504","./EllipsoidRhumbLine-c86f0674","./IntersectionTests-4d132f79","./Plane-7e828ad8"],(function(e,t,i,n,r,o,a,s,l,m,d,p,u,c,f,h,g,y,C){"use strict";const w=new t.Cartesian3,b=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,v=new t.Cartesian3,A=new t.Cartesian3,_=new t.Cartesian3;function F(i){const o=(i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT)).positions,a=i.maximumHeights,s=i.minimumHeights;if(!e.defined(o))throw new r.DeveloperError("options.positions is required.");if(e.defined(a)&&a.length!==o.length)throw new r.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(s)&&s.length!==o.length)throw new r.DeveloperError("options.positions and options.minimumHeights must have the same length.");const m=e.defaultValue(i.vertexFormat,l.VertexFormat.DEFAULT),d=e.defaultValue(i.granularity,n.CesiumMath.RADIANS_PER_DEGREE),p=e.defaultValue(i.ellipsoid,t.Ellipsoid.WGS84);this._positions=o,this._minimumHeights=s,this._maximumHeights=a,this._vertexFormat=l.VertexFormat.clone(m),this._granularity=d,this._ellipsoid=t.Ellipsoid.clone(p),this._workerName="createWallGeometry";let u=1+o.length*t.Cartesian3.packedLength+2;e.defined(s)&&(u+=s.length),e.defined(a)&&(u+=a.length),this.packedLength=u+t.Ellipsoid.packedLength+l.VertexFormat.packedLength+1}F.pack=function(i,n,o){if(!e.defined(i))throw new r.DeveloperError("value is required");if(!e.defined(n))throw new r.DeveloperError("array is required");let a;o=e.defaultValue(o,0);const s=i._positions;let m=s.length;for(n[o++]=m,a=0;a<m;++a,o+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[a],n,o);const d=i._minimumHeights;if(m=e.defined(d)?d.length:0,n[o++]=m,e.defined(d))for(a=0;a<m;++a)n[o++]=d[a];const p=i._maximumHeights;if(m=e.defined(p)?p.length:0,n[o++]=m,e.defined(p))for(a=0;a<m;++a)n[o++]=p[a];return t.Ellipsoid.pack(i._ellipsoid,n,o),o+=t.Ellipsoid.packedLength,l.VertexFormat.pack(i._vertexFormat,n,o),n[o+=l.VertexFormat.packedLength]=i._granularity,n};const D=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),H=new l.VertexFormat,L={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:D,vertexFormat:H,granularity:void 0};return F.unpack=function(i,n,o){if(!e.defined(i))throw new r.DeveloperError("array is required");let a;n=e.defaultValue(n,0);let s=i[n++];const m=new Array(s);for(a=0;a<s;++a,n+=t.Cartesian3.packedLength)m[a]=t.Cartesian3.unpack(i,n);let d,p;if(s=i[n++],s>0)for(d=new Array(s),a=0;a<s;++a)d[a]=i[n++];if(s=i[n++],s>0)for(p=new Array(s),a=0;a<s;++a)p[a]=i[n++];const u=t.Ellipsoid.unpack(i,n,D);n+=t.Ellipsoid.packedLength;const c=l.VertexFormat.unpack(i,n,H),f=i[n+=l.VertexFormat.packedLength];return e.defined(o)?(o._positions=m,o._minimumHeights=d,o._maximumHeights=p,o._ellipsoid=t.Ellipsoid.clone(u,o._ellipsoid),o._vertexFormat=l.VertexFormat.clone(c,o._vertexFormat),o._granularity=f,o):(L.positions=m,L.minimumHeights=d,L.maximumHeights=p,L.granularity=f,new F(L))},F.fromConstantHeights=function(t){const i=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions;if(!e.defined(i))throw new r.DeveloperError("options.positions is required.");let n,o;const a=t.minimumHeight,s=t.maximumHeight,l=e.defined(a),m=e.defined(s);if(l||m){const e=i.length;n=l?new Array(e):void 0,o=m?new Array(e):void 0;for(let t=0;t<e;++t)l&&(n[t]=a),m&&(o[t]=s)}return new F({positions:i,maximumHeights:o,minimumHeights:n,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},F.createGeometry=function(r){const l=r._positions,d=r._minimumHeights,p=r._maximumHeights,u=r._vertexFormat,c=r._granularity,f=r._ellipsoid,h=m.WallGeometryLibrary.computePositions(f,l,p,d,c,!0);if(!e.defined(h))return;const g=h.bottomPositions,y=h.topPositions,C=h.numCorners;let F=y.length,D=2*F;const H=u.position?new Float64Array(D):void 0,L=u.normal?new Float32Array(D):void 0,V=u.tangent?new Float32Array(D):void 0,k=u.bitangent?new Float32Array(D):void 0,G=u.st?new Float32Array(D/3*2):void 0;let P,T=0,z=0,O=0,R=0,S=0,I=_,q=A,N=v,M=!0;F/=3;let W=0;const B=1/(F-C-1);for(P=0;P<F;++P){const e=3*P,i=t.Cartesian3.fromArray(y,e,w),r=t.Cartesian3.fromArray(g,e,b);if(u.position&&(H[T++]=r.x,H[T++]=r.y,H[T++]=r.z,H[T++]=i.x,H[T++]=i.y,H[T++]=i.z),u.st&&(G[S++]=W,G[S++]=0,G[S++]=W,G[S++]=1),u.normal||u.tangent||u.bitangent){let r=t.Cartesian3.clone(t.Cartesian3.ZERO,E);const o=t.Cartesian3.subtract(i,f.geodeticSurfaceNormal(i,b),b);if(P+1<F&&(r=t.Cartesian3.fromArray(y,e+3,E)),M){const e=t.Cartesian3.subtract(r,i,x),n=t.Cartesian3.subtract(o,i,w);I=t.Cartesian3.normalize(t.Cartesian3.cross(n,e,I),I),M=!1}t.Cartesian3.equalsEpsilon(i,r,n.CesiumMath.EPSILON10)?M=!0:(W+=B,u.tangent&&(q=t.Cartesian3.normalize(t.Cartesian3.subtract(r,i,q),q)),u.bitangent&&(N=t.Cartesian3.normalize(t.Cartesian3.cross(I,q,N),N))),u.normal&&(L[z++]=I.x,L[z++]=I.y,L[z++]=I.z,L[z++]=I.x,L[z++]=I.y,L[z++]=I.z),u.tangent&&(V[R++]=q.x,V[R++]=q.y,V[R++]=q.z,V[R++]=q.x,V[R++]=q.y,V[R++]=q.z),u.bitangent&&(k[O++]=N.x,k[O++]=N.y,k[O++]=N.z,k[O++]=N.x,k[O++]=N.y,k[O++]=N.z)}}const U=new a.GeometryAttributes;u.position&&(U.position=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:H})),u.normal&&(U.normal=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L})),u.tangent&&(U.tangent=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),u.bitangent&&(U.bitangent=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k})),u.st&&(U.st=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:G}));const J=D/3;D-=6*(C+1);const Y=s.IndexDatatype.createTypedArray(J,D);let j=0;for(P=0;P<J-2;P+=2){const e=P,i=P+2,r=t.Cartesian3.fromArray(H,3*e,w),o=t.Cartesian3.fromArray(H,3*i,b);if(t.Cartesian3.equalsEpsilon(r,o,n.CesiumMath.EPSILON10))continue;const a=P+1,s=P+3;Y[j++]=a,Y[j++]=e,Y[j++]=s,Y[j++]=s,Y[j++]=e,Y[j++]=i}return new o.Geometry({attributes:U,indices:Y,primitiveType:o.PrimitiveType.TRIANGLES,boundingSphere:new i.BoundingSphere.fromVertices(H)})},function(i,n){return e.defined(n)&&(i=F.unpack(i,n)),i._ellipsoid=t.Ellipsoid.clone(i._ellipsoid),F.createGeometry(i)}}));