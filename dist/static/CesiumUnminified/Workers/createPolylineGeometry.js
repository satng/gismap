define(["./defaultValue-81eec7ed","./Matrix2-c430e55a","./ArcType-fc72c06c","./arrayRemoveDuplicates-1a15bd09","./Transforms-4ee811db","./Color-8d08a55c","./ComponentDatatype-9e86ac8f","./RuntimeError-8952249c","./GeometryAttribute-51ed9bde","./GeometryAttributes-32b29525","./IndexDatatype-bed3935d","./PolylinePipeline-b3067570","./VertexFormat-7df34ea5","./_commonjsHelpers-3aae1032-26891ab7","./combine-3c023bda","./WebGLConstants-508b9636","./EllipsoidGeodesic-22d2f504","./EllipsoidRhumbLine-c86f0674","./IntersectionTests-4d132f79","./Plane-7e828ad8"],(function(e,t,o,r,n,a,i,l,s,c,p,d,u,y,m,f,h,C,g,w){"use strict";const E=[];function _(e,t,o,r,n){const i=E;let l;i.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,y=r.green,m=r.blue,f=r.alpha;if(a.Color.equals(o,r)){for(l=0;l<n;l++)i[l]=a.Color.clone(o);return i}const h=(u-s)/n,C=(y-c)/n,g=(m-p)/n,w=(f-d)/n;for(l=0;l<n;l++)i[l]=new a.Color(s+l*h,c+l*C,p+l*g,d+l*w);return i}function b(r){const n=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,s=r.colors,c=e.defaultValue(r.width,1),p=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(n)||n.length<2)throw new l.DeveloperError("At least two positions are required.");if("number"!=typeof c)throw new l.DeveloperError("width must be a number");if(e.defined(s)&&(p&&s.length<n.length||!p&&s.length<n.length-1))throw new l.DeveloperError("colors has an invalid length.");this._positions=n,this._colors=s,this._width=c,this._colorsPerVertex=p,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(r.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,i.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let d=1+n.length*t.Cartesian3.packedLength;d+=e.defined(s)?1+s.length*a.Color.packedLength:1,this.packedLength=d+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}b.pack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("value is required");if(!e.defined(r))throw new l.DeveloperError("array is required");let i;n=e.defaultValue(n,0);const s=o._positions;let c=s.length;for(r[n++]=c,i=0;i<c;++i,n+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[i],r,n);const p=o._colors;for(c=e.defined(p)?p.length:0,r[n++]=c,i=0;i<c;++i,n+=a.Color.packedLength)a.Color.pack(p[i],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,u.VertexFormat.pack(o._vertexFormat,r,n),n+=u.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const A=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),P=new u.VertexFormat,v={positions:void 0,colors:void 0,ellipsoid:A,vertexFormat:P,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};b.unpack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("array is required");let i;r=e.defaultValue(r,0);let s=o[r++];const c=new Array(s);for(i=0;i<s;++i,r+=t.Cartesian3.packedLength)c[i]=t.Cartesian3.unpack(o,r);s=o[r++];const p=s>0?new Array(s):void 0;for(i=0;i<s;++i,r+=a.Color.packedLength)p[i]=a.Color.unpack(o,r);const d=t.Ellipsoid.unpack(o,r,A);r+=t.Ellipsoid.packedLength;const y=u.VertexFormat.unpack(o,r,P);r+=u.VertexFormat.packedLength;const m=o[r++],f=1===o[r++],h=o[r++],C=o[r];return e.defined(n)?(n._positions=c,n._colors=p,n._ellipsoid=t.Ellipsoid.clone(d,n._ellipsoid),n._vertexFormat=u.VertexFormat.clone(y,n._vertexFormat),n._width=m,n._colorsPerVertex=f,n._arcType=h,n._granularity=C,n):(v.positions=c,v.colors=p,v.width=m,v.colorsPerVertex=f,v.arcType=h,v.granularity=C,new b(v))};const D=new t.Cartesian3,x=new t.Cartesian3,T=new t.Cartesian3,k=new t.Cartesian3;return b.createGeometry=function(l){const u=l._width,y=l._vertexFormat;let m=l._colors;const f=l._colorsPerVertex,h=l._arcType,C=l._granularity,g=l._ellipsoid;let w,b,A;const P=[];let v=r.arrayRemoveDuplicates(l._positions,t.Cartesian3.equalsEpsilon,!1,P);if(e.defined(m)&&P.length>0){let e=0,t=P[0];m=m.filter((function(o,r){let n=!1;return n=f?r===t||0===r&&1===t:r+1===t,!n||(e++,t=P[e],!1)}))}let V=v.length;if(V<2||u<=0)return;if(h===o.ArcType.GEODESIC||h===o.ArcType.RHUMB){let t,r;h===o.ArcType.GEODESIC?(t=i.CesiumMath.chordLength(C,g.maximumRadius),r=d.PolylinePipeline.numberOfPoints):(t=C,r=d.PolylinePipeline.numberOfPointsRhumbLine);const n=d.PolylinePipeline.extractHeights(v,g);if(e.defined(m)){let e=1;for(w=0;w<V-1;++w)e+=r(v[w],v[w+1],t);const o=new Array(e);let n=0;for(w=0;w<V-1;++w){const i=v[w],l=v[w+1],s=m[w],c=r(i,l,t);if(f&&w<e){const e=_(0,0,s,m[w+1],c),t=e.length;for(b=0;b<t;++b)o[n++]=e[b]}else for(b=0;b<c;++b)o[n++]=a.Color.clone(s)}o[n]=a.Color.clone(m[m.length-1]),m=o,E.length=0}v=h===o.ArcType.GEODESIC?d.PolylinePipeline.generateCartesianArc({positions:v,minDistance:t,ellipsoid:g,height:n}):d.PolylinePipeline.generateCartesianRhumbArc({positions:v,granularity:t,ellipsoid:g,height:n})}V=v.length;const L=4*V-4,F=new Float64Array(3*L),G=new Float64Array(3*L),O=new Float64Array(3*L),R=new Float32Array(2*L),I=y.st?new Float32Array(2*L):void 0,S=e.defined(m)?new Uint8Array(4*L):void 0;let B,U=0,N=0,q=0,M=0;for(b=0;b<V;++b){let o,r;0===b?(B=D,t.Cartesian3.subtract(v[0],v[1],B),t.Cartesian3.add(v[0],B,B)):B=v[b-1],t.Cartesian3.clone(B,T),t.Cartesian3.clone(v[b],x),b===V-1?(B=D,t.Cartesian3.subtract(v[V-1],v[V-2],B),t.Cartesian3.add(v[V-1],B,B)):B=v[b+1],t.Cartesian3.clone(B,k),e.defined(S)&&(o=0===b||f?m[b]:m[b-1],b!==V-1&&(r=m[b]));const n=b===V-1?2:4;for(A=0===b?2:0;A<n;++A){t.Cartesian3.pack(x,F,U),t.Cartesian3.pack(T,G,U),t.Cartesian3.pack(k,O,U),U+=3;const n=A-2<0?-1:1;if(R[N++]=A%2*2-1,R[N++]=n*u,y.st&&(I[q++]=b/(V-1),I[q++]=Math.max(R[N-2],0)),e.defined(S)){const e=A<2?o:r;S[M++]=a.Color.floatToByte(e.red),S[M++]=a.Color.floatToByte(e.green),S[M++]=a.Color.floatToByte(e.blue),S[M++]=a.Color.floatToByte(e.alpha)}}}const H=new c.GeometryAttributes;H.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}),H.prevPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),H.nextPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),H.expandAndWidth=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R}),y.st&&(H.st=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I})),e.defined(S)&&(H.color=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));const W=p.IndexDatatype.createTypedArray(L,6*V-6);let Y=0,j=0;const z=V-1;for(b=0;b<z;++b)W[j++]=Y,W[j++]=Y+2,W[j++]=Y+1,W[j++]=Y+1,W[j++]=Y+2,W[j++]=Y+3,Y+=4;return new s.Geometry({attributes:H,indices:W,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(v),geometryType:s.GeometryType.POLYLINES})},function(o,r){return e.defined(r)&&(o=b.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),b.createGeometry(o)}}));