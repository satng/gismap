define(["exports","./GeometryOffsetAttribute-2bff0974","./Transforms-4ee811db","./Matrix2-c430e55a","./ComponentDatatype-9e86ac8f","./CylinderGeometryLibrary-0fa93765","./defaultValue-81eec7ed","./RuntimeError-8952249c","./GeometryAttribute-51ed9bde","./GeometryAttributes-32b29525","./IndexDatatype-bed3935d","./VertexFormat-7df34ea5"],(function(t,e,r,o,n,a,i,s,u,m,d,f){"use strict";const l=new o.Cartesian2,p=new o.Cartesian3,c=new o.Cartesian3,y=new o.Cartesian3,b=new o.Cartesian3;function A(t){const r=(t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT)).length,o=t.topRadius,n=t.bottomRadius,a=i.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT),u=i.defaultValue(t.slices,128);if(!i.defined(r))throw new s.DeveloperError("options.length must be defined.");if(!i.defined(o))throw new s.DeveloperError("options.topRadius must be defined.");if(!i.defined(n))throw new s.DeveloperError("options.bottomRadius must be defined.");if(u<3)throw new s.DeveloperError("options.slices must be greater than or equal to 3.");if(i.defined(t.offsetAttribute)&&t.offsetAttribute===e.GeometryOffsetAttribute.TOP)throw new s.DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=r,this._topRadius=o,this._bottomRadius=n,this._vertexFormat=f.VertexFormat.clone(a),this._slices=u,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}A.packedLength=f.VertexFormat.packedLength+5,A.pack=function(t,e,r){if(!i.defined(t))throw new s.DeveloperError("value is required");if(!i.defined(e))throw new s.DeveloperError("array is required");return r=i.defaultValue(r,0),f.VertexFormat.pack(t._vertexFormat,e,r),r+=f.VertexFormat.packedLength,e[r++]=t._length,e[r++]=t._topRadius,e[r++]=t._bottomRadius,e[r++]=t._slices,e[r]=i.defaultValue(t._offsetAttribute,-1),e};const h=new f.VertexFormat,w={vertexFormat:h,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let g;A.unpack=function(t,e,r){if(!i.defined(t))throw new s.DeveloperError("array is required");e=i.defaultValue(e,0);const o=f.VertexFormat.unpack(t,e,h);e+=f.VertexFormat.packedLength;const n=t[e++],a=t[e++],u=t[e++],m=t[e++],d=t[e];return i.defined(r)?(r._vertexFormat=f.VertexFormat.clone(o,r._vertexFormat),r._length=n,r._topRadius=a,r._bottomRadius=u,r._slices=m,r._offsetAttribute=-1===d?void 0:d,r):(w.length=n,w.topRadius=a,w.bottomRadius=u,w.slices=m,w.offsetAttribute=-1===d?void 0:d,new A(w))},A.createGeometry=function(t){let s=t._length;const f=t._topRadius,A=t._bottomRadius,h=t._vertexFormat,w=t._slices;if(s<=0||f<0||A<0||0===f&&0===A)return;const g=w+w,v=w+g,x=g+g,_=a.CylinderGeometryLibrary.computePositions(s,f,A,w,!0),F=h.st?new Float32Array(2*x):void 0,C=h.normal?new Float32Array(3*x):void 0,D=h.tangent?new Float32Array(3*x):void 0,G=h.bitangent?new Float32Array(3*x):void 0;let R;const O=h.normal||h.tangent||h.bitangent;if(O){const t=h.tangent||h.bitangent;let e=0,r=0,a=0;const i=Math.atan2(A-f,s),u=p;u.z=Math.sin(i);const m=Math.cos(i);let d=y,l=c;for(R=0;R<w;R++){const i=R/w*n.CesiumMath.TWO_PI,s=m*Math.cos(i),f=m*Math.sin(i);O&&(u.x=s,u.y=f,t&&(d=o.Cartesian3.normalize(o.Cartesian3.cross(o.Cartesian3.UNIT_Z,u,d),d)),h.normal&&(C[e++]=u.x,C[e++]=u.y,C[e++]=u.z,C[e++]=u.x,C[e++]=u.y,C[e++]=u.z),h.tangent&&(D[r++]=d.x,D[r++]=d.y,D[r++]=d.z,D[r++]=d.x,D[r++]=d.y,D[r++]=d.z),h.bitangent&&(l=o.Cartesian3.normalize(o.Cartesian3.cross(u,d,l),l),G[a++]=l.x,G[a++]=l.y,G[a++]=l.z,G[a++]=l.x,G[a++]=l.y,G[a++]=l.z))}for(R=0;R<w;R++)h.normal&&(C[e++]=0,C[e++]=0,C[e++]=-1),h.tangent&&(D[r++]=1,D[r++]=0,D[r++]=0),h.bitangent&&(G[a++]=0,G[a++]=-1,G[a++]=0);for(R=0;R<w;R++)h.normal&&(C[e++]=0,C[e++]=0,C[e++]=1),h.tangent&&(D[r++]=1,D[r++]=0,D[r++]=0),h.bitangent&&(G[a++]=0,G[a++]=1,G[a++]=0)}const V=12*w-12,E=d.IndexDatatype.createTypedArray(x,V);let T=0,L=0;for(R=0;R<w-1;R++)E[T++]=L,E[T++]=L+2,E[T++]=L+3,E[T++]=L,E[T++]=L+3,E[T++]=L+1,L+=2;for(E[T++]=g-2,E[T++]=0,E[T++]=1,E[T++]=g-2,E[T++]=1,E[T++]=g-1,R=1;R<w-1;R++)E[T++]=g+R+1,E[T++]=g+R,E[T++]=g;for(R=1;R<w-1;R++)E[T++]=v,E[T++]=v+R,E[T++]=v+R+1;let P=0;if(h.st){const t=Math.max(f,A);for(R=0;R<x;R++){const e=o.Cartesian3.fromArray(_,3*R,b);F[P++]=(e.x+t)/(2*t),F[P++]=(e.y+t)/(2*t)}}const M=new m.GeometryAttributes;h.position&&(M.position=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:_})),h.normal&&(M.normal=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),h.tangent&&(M.tangent=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),h.bitangent&&(M.bitangent=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),h.st&&(M.st=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:F})),l.x=.5*s,l.y=Math.max(A,f);const k=new r.BoundingSphere(o.Cartesian3.ZERO,o.Cartesian2.magnitude(l));if(i.defined(t._offsetAttribute)){s=_.length;const r=new Uint8Array(s/3),o=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(r,o),M.applyOffset=new u.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new u.Geometry({attributes:M,indices:E,primitiveType:u.PrimitiveType.TRIANGLES,boundingSphere:k,offsetAttribute:t._offsetAttribute})},A.getUnitCylinder=function(){return i.defined(g)||(g=A.createGeometry(new A({topRadius:1,bottomRadius:1,length:1,vertexFormat:f.VertexFormat.POSITION_ONLY}))),g},t.CylinderGeometry=A}));